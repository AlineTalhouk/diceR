#' External validity indices
#' 
#' \strong{E}xternal \strong{v}alidity indices compare a predicted clustering 
#' result with a reference class or gold standard.
#' 
#' \code{ev_accuracy} computes the classification accuracy for a clustering
#' result
#' 
#' @param pred.lab predicted labels generated by classifier
#' @param ref.lab reference labels for the observations
#' @references MATLAB function valid_CA and valid_RandIndex in package LinkCluE by Simon Garrett   
#' @return \code{ev_accuracy} returns the classification accuracy
#' @name external_validity
#' @export
#' 
#' @examples
#' data("E_LCE")
#' ev_accuracy(c(4, 4, 4, 4), c(4, 2, 4, 4))
#' ev_accuracy(c(4, 4, 4, 4, 8), c(4, 2, 4, 4, 6))
#' ev_rand(E_LCE[, 1], E_LCE[, 2])
ev_accuracy <- function(pred.lab, ref.lab) {
  assertthat::assert_that(is.vector(pred.lab), is.vector(ref.lab))
  nrow <- length(ref.lab)
  C <- sort(unique(pred.lab))
  k <- length(C)
  clusters <- list(NULL)
  for (i in 2:k) {
    clusters <- c(clusters, NULL)
  }
  ca <- 0
  for (i in 1:k) {
    ind <- which(pred.lab == C[i])
    clusters[[i]] <- matrix(ind, ncol = 1)
    n <- length(ind)
    temp <- NULL
    for (j in 1:n) {
      temp <- append(temp, ref.lab[ind[j]])
    }
    clusters[[i]] <- cbind(clusters[[i]], temp)
    TC <- sort(unique(clusters[[i]][, 2]))
    kTC <- length(TC)
    ind <- NULL
    for (l in 1:kTC) {
      ind <- append(ind, length(which(clusters[[i]][, 2] == TC[l])))
    }
    M <- max(ind)
    I <- which(ind == M)
    ca <- ca + M
  }
  return(ca / nrow)
}

#' @details \code{ev_rand} calculates Rand indices (and their variants)to
#'   compare two partitions
#' @return \code{ev_rand} returns a list with elements
#'   \item{AR}{adjusted Rand index}
#'   \item{RI}{unadjusted Rand index}
#'   \item{MI}{Mirkin's index}
#'   \item{HI}{Hubert's index}
#' @rdname external_validity
#' @export
ev_rand <- function(pred.lab, ref.lab) {
  assertthat::assert_that(is.vector(pred.lab))
  assertthat::assert_that(is.vector(ref.lab))
  C <- table(pred.lab, ref.lab)
  n <- sum(C)
  nis <- sum(rowSums(C) ^ 2)
  njs <- sum(colSums(C) ^ 2)
  t1 <- n * (n - 1) / 2
  t2 <- sum(C ^ 2)
  t3 <- 0.5 * (nis + njs)
  nc <- (n * (n ^ 2 + 1) - (n + 1) * nis - (n + 1) * njs + 2 * (nis * njs) /
           n) / (2 * (n - 1))
  A <- t1 + t2 - t3
  D <- t3 - t2
  if (t1 == nc) {
    AR <- 0
  } else{
    AR <- (A - nc) / (t1 - nc)
  }
  RI <- A / t1
  MI <- D / t1
  HI <- (A - D) / t1
  return(list(
    AR = AR,
    RI = RI,
    MI = MI,
    HI = HI
  ))
}