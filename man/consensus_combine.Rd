% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/consensus_combine.R, R/consensus_evaluate.R,
%   R/consensus_weigh.R
\name{consensus_combine}
\alias{consensus_combine}
\alias{consensus_evaluate}
\alias{consensus_weigh}
\title{Combine, evaluate, and weigh algorithms}
\usage{
consensus_combine(..., k = NULL, progress = TRUE, element = c("matrix",
  "class"), alg.names = NULL)

consensus_evaluate(data, k, ..., cons.cl = NULL, ref.cl = NULL,
  plot = TRUE)

consensus_weigh(data.index, top = 5)
}
\arguments{
\item{...}{any number of objects outputted from
\code{\link{ConClust}}}

\item{k}{number of clusters requested. Default is \code{NULL}, which returns
all k computed from \code{...}}

\item{progress}{Should a progress bar be printed?}

\item{element}{either "matrix" or "class" to extract the consensus matrix or
consensus class, respectively.}

\item{alg.names}{optional. Supply a vector of names for the algorithms.}

\item{data}{data matrix with rows as samples and columns as variables}

\item{cons.cl}{matrix of cluster assignments from consensus algorithms such
as \code{kmodes} and \code{majority_voting}}

\item{ref.cl}{reference class}

\item{plot}{logical; if \code{TRUE}, \code{graph_all} is called}

\item{data.index}{matrix of indices for each algorthim outputted from
\code{consensus_evaluate}.}

\item{top}{how many top algorithms to include for weighting. Defaults to 5.}
}
\value{
\code{consensus_combine} returns either a list of all consensus
  matrices or a data frame showing all the consensus classes

\code{consensus_evaluate} returns a data frame of the indices in each
  column for each algorithm.

\code{consensus_weigh} returns a matrix of weighted algorithms.
}
\description{
\code{consensus_combine} combines results for multiple objects from
\code{ConClust()} and outputs either the consensus
matrices or consensus classes for all algorithms. \code{consensus_evaluate}
evaluates algorithms on internal/external validation indices.
\code{consensus_weigh} weighs clustering algorithms based on these two
indices.
}
\details{
\code{consensus_combine} is useful for generating summaries because the
results have been combined into a single object. For example, if
\code{element = "class"}, then the resulting object can be used to create a
consensus matrix across algorithms, which can be visualized as a heatmap.

\code{consensus_evaluate} always shows internal indices. If \code{ref.cl} is
not \code{NULL}, external indices are shown in addition to internal indices.
Relevant graphical displays are also outputted.
}
\examples{
# Consensus clustering for multiple algorithms
set.seed(911)
x <- matrix(rnorm(1000), ncol = 10)
CC1 <- ConClust(x, nc = 2:4, reps = 10, method = "apEucl")
CC2 <- ConClust(x, nc = 2:4, reps = 10, method = "gmmBIC")

# Combine and return either matrices or classes
y1 <- consensus_combine(CC1, CC2, k = 4, element = "matrix")
str(y1)
y2 <- consensus_combine(CC1, CC2, k = 4, element = "class")
str(y2)

# Evaluate algorithms on internal and external indices and make plots
set.seed(1)
ref.cl <- sample(1:4, 100, replace = TRUE)
z.internal <- consensus_evaluate(x, k = 4, CC1, CC2)
z <- consensus_evaluate(x, k = 4, CC1, CC2, ref.cl = ref.cl, plot = FALSE)
}
\author{
Derek Chiu
}
\seealso{
Other consensus functions: \code{\link{consensus_class}},
  \code{\link{consensus_confmat}},
  \code{\link{consensus_matrix}},
  \code{\link{consensus_summary}}
}

