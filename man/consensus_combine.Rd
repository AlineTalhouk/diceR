% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/consensus_combine.R, R/consensus_evaluate.R,
%   R/consensus_trim.R
\name{consensus_combine}
\alias{consensus_combine}
\alias{consensus_evaluate}
\alias{consensus_trim}
\title{Combine, evaluate, trim, and weigh algorithms}
\usage{
consensus_combine(..., k = NULL, progress = TRUE, element = c("matrix",
  "class"), alg.names = NULL)

consensus_evaluate(data, k, ..., cons.cl = NULL, ref.cl = NULL,
  plot = TRUE)

consensus_trim(data, k, ..., cons.cl = NULL, ref.cl = NULL,
  quantile = 0.75, reweigh = FALSE)
}
\arguments{
\item{...}{any number of objects outputted from
\code{\link{ConClust}}}

\item{k}{number of clusters requested. Default is \code{NULL}, which returns
all k computed from \code{...}}

\item{progress}{Should a progress bar be printed?}

\item{element}{either "matrix" or "class" to extract the consensus matrix or
consensus class, respectively.}

\item{alg.names}{optional. Supply a vector of names for the algorithms.}

\item{data}{data matrix with rows as samples and columns as variables}

\item{cons.cl}{matrix of cluster assignments from consensus algorithms such
as \code{kmodes} and \code{majority_voting}}

\item{ref.cl}{reference class}

\item{plot}{logical; if \code{TRUE}, \code{graph_all} is called}

\item{quantile}{if an algorithm's sum of ranks across indices is in the 
\code{quantile} quantile, the algorithm is kept. Otherwise it is removed 
(trimmed).}

\item{reweigh}{logical; if \code{TRUE}, after trimming out poor performing
algorithms, each algorithm is reweighed depending on its internal indices.}
}
\value{
\code{consensus_combine} returns either a list of all consensus
  matrices or a data frame showing all the consensus classes

\code{consensus_evaluate} returns a data frame of the indices in each
  column for each algorithm.

\code{consensus_trim} returns a list with three elements 
  \item{alg.keep}{algorithms kept} \item{alg.remove}{algorithms removed} 
  \item{E_trimmed}{A trimmed version of a \code{ConClust} object. Potentially
  no different than original depending on \code{quantile}}
}
\description{
\code{consensus_combine} combines results for multiple objects from
\code{ConClust()} and outputs either the consensus
matrices or consensus classes for all algorithms. \code{consensus_evaluate}
evaluates algorithms on internal/external validation indices.
\code{consensus_weigh} weighs clustering algorithms based on these two
indices. \code{consensus_trim} removes algorithms that rank low on internal
indices before using in ensemble clustering methods.
}
\details{
\code{consensus_combine} is useful for generating summaries because the
results have been combined into a single object. For example, if
\code{element = "class"}, then the resulting object can be used to create a
consensus matrix across algorithms, which can be visualized as a heatmap.

\code{consensus_evaluate} always shows internal indices. If \code{ref.cl} is
not \code{NULL}, external indices are shown in addition to internal indices.
Relevant graphical displays are also outputted.

\code{consensus_trim} ranks algorithms by internal indices used in
\code{consensus_evaluate}. The sum of the ranks for each algorithm is used as
the measure of comparison. This also means the magnitude of the internal
indices is not taken into account.
}
\examples{
# Consensus clustering for multiple algorithms
set.seed(911)
x <- matrix(rnorm(1000), ncol = 10)
CC1 <- ConClust(x, nc = 3:4, reps = 10, method = "apEucl")
CC2 <- ConClust(x, nc = 3:4, reps = 10, method = "gmmBIC")

# Combine and return either matrices or classes
y1 <- consensus_combine(CC1, CC2, k = 4, element = "matrix")
str(y1)
y2 <- consensus_combine(CC1, CC2, k = 4, element = "class")
str(y2)

# Evaluate algorithms on internal and external indices and make plots
set.seed(1)
ref.cl <- sample(1:4, 100, replace = TRUE)
z.internal <- consensus_evaluate(x, k = 4, CC1, CC2)
z <- consensus_evaluate(x, k = 4, CC1, CC2, ref.cl = ref.cl, plot = FALSE)

# Trim algorithms: remove those that rank low on internal indices
CC3 <- consensus_trim(x, k = 4, CC1, CC2, ref.cl = ref.cl, quantile = 0.8)
str(CC3)
}
\author{
Derek Chiu
}
\seealso{
Other consensus functions: \code{\link{consensus_class}},
  \code{\link{consensus_confmat}},
  \code{\link{consensus_matrix}},
  \code{\link{consensus_summary}}
}

