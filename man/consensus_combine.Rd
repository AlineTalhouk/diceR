% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/consensus_combine.R, R/consensus_evaluate.R,
%   R/consensus_weigh.R
\name{consensus_combine}
\alias{consensus_combine}
\alias{consensus_evaluate}
\alias{consensus_weigh}
\title{Combine, evaluate, and weigh algorithms}
\usage{
consensus_combine(..., element = c("matrix", "class"), alg.names = NULL)

consensus_evaluate(data, cl.mat, cons.mat, ref.cl = NULL, alg.names = NULL)

consensus_weigh(data.index, top = 5)
}
\arguments{
\item{...}{any number of objects outputted from
\code{\link{consensus_summary}}}

\item{element}{either "matrix" or "class" to extract the consensus matrix or
consensus class, respectively.}

\item{alg.names}{optional. Supply a vector of names for the algorithms.}

\item{data}{data matrix with rows as samples and columns as variables}

\item{cl.mat}{matrix of cluster assignments. Each row is an assignment for a
different algorithm. Use \code{element = "class"} in
\code{consensus_combine}.}

\item{cons.mat}{A list of consensus matrices, one for each algorithm. Use
\code{element = "matrix"} in \code{consensus_combine}.}

\item{ref.cl}{reference class}

\item{data.index}{matrix of indices for each algorthim outputted from
\code{consensus_evaluate}.}

\item{top}{how many top algorithms to include for weighting. Defaults to 5.}
}
\value{
\code{consensus_combine} returns either a list of all consensus
  matrices or a data frame showing all the consensus classes

\code{consensus_evaluate} returns a data frame of the indices PAC and
  CHI in each column for each algorithm.

\code{consensus_weigh} returns a matrix of weighted algorithms.
}
\description{
\code{consensus_combine} combines results for multiple objects from
\code{consensus_summary(ConClust())} and outputs either the consensus
matrices or consensus classes for all algorithms. \code{consensus_evaluate}
evaluates algorithms on internal/external validation indices.
\code{consensus_weigh} weighs clustering algorithms based on these two
indices.
}
\details{
\code{consensus_combine} is useful for generating summaries because the
results have been combined into a single object. For example, if
\code{element = "class"}, then the resulting object can be used to create a
consensus matrix across algorithms, which can be visualized as a heatmap.

\code{consensus_evaluate} always shows internal indices. If \code{ref.cl} is
not \code{NULL}, external indices are shown in addition to internal indices.
Relevant graphical displays are also outputted.
}
\examples{
# Consensus clustering for multiple algorithms
set.seed(911)
x <- matrix(rnorm(1000), ncol = 10)
CC1 <- ConClust(x, k = 4, reps = 10, method = "apEucl")
CC2 <- ConClust(x, k = 4, reps = 10, method = "gmmBIC")

# Get summary for ConClust
CC1.summ <- consensus_summary(CC1, k = 4)
CC2.summ <- consensus_summary(CC2, k = 4)

# Combine and return either matrices or classes
y1 <- consensus_combine(CC1.summ, CC2.summ, element = "matrix")
str(y1)
y2 <- consensus_combine(CC1.summ, CC2.summ, element = "class")
str(y2)

# Evaluate algorithms on internal and external indices
set.seed(1)
ref.cl <- sample(1:4, 100, replace = TRUE)
z.internal <- consensus_evaluate(x, cl.mat = y2, cons.mat = y1)
z <- consensus_evaluate(x, cl.mat = y2, cons.mat = y1, ref.cl = ref.cl)

# Weigh algorithms
consensus_weigh(z)
}
\author{
Derek Chiu
}
\seealso{
Other consensus functions: \code{\link{consensus_class}},
  \code{\link{consensus_confmat}},
  \code{\link{consensus_matrix}},
  \code{\link{consensus_summary}}
}

